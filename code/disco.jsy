import {MQTT_base} from './base.jsy'

export class MQTT_disco extends MQTT_base ::
  static from(pi_ctx, mqtt, url) ::
    return new this(pi_ctx)
      .with_mqtt(mqtt)
      .subscribe(url)

  subscribe(url) ::
    this.mqtt.on_topic @ url.pathname+':id',
      this.on_advert.bind(this)
    this.mqtt.subscribe(url.pathname + '#')
    return this.with @:
      url: new URL('.', url)
      db_adverts: new Map()
      db_chans: new Map()

  advert_from_pkt(pkt) ::
    return pkt.json()

  on_advert(pkt, {id}) ::
    if 0 === pkt.payload.length ::
      this.db_adverts.delete(id)
      this.db_chans.delete(id)
    else ::
      this.db_adverts.set @ id,
        this.advert_from_pkt(pkt)

  query_key(query) :: return query.id_route

  // addDiscovery protocol {test, discover}
  test(query) :: return true
  async discover(query) ::
    let key = await this.query_key(query)
    let db_chans = this.db_chans
    let cur = db_chans.get(key)
    if ! cur ::
      cur = this._use_advert(key, query)
      db_chans.set(key, cur)
    return cur

  // retries = 3
  // ms_backoff = 50
  async _use_advert(key, query) ::
    let db_adverts = this.db_adverts,
        hub = query.router_ctx.hub,
        advert
    for let i=this.retries || 3; i>0; i-- ::
      advert = await db_adverts.get(key)
      if advert :: break
      await hub.timeouts.add(this.ms_backoff || 50)

    return advert && this._channel_to(hub, advert, query)

  async _channel_to(hub, advert, query) ::
    if ! advert.conn :: return
    let chan = await hub.connect(advert.conn)
    let peer = await chan.peer_info
    this.on_connect(advert, peer, chan)
    return chan

  on_connect(advert, peer, chan) ::
    //console.log @ 'connected to:', advert, peer

