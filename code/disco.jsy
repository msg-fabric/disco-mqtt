
const _mqtt_disco_ = /* #__PURE__ */ @{}
  from(mqtt, url, discover) ::
    let _conn = mqtt.connect()
    return @{} __proto__: this,
      discover, url, mqtt, _conn

  test: q => true
  discover(q) ::

  async channel_to(hub, advert, query) ::
    let chan = await hub.connect(advert.conn)
    let peer = await chan.peer_info
    this.on_connect(advert, peer, chan)
    return chan

  retries: 3, ms_backoff: 50
  on_connect(advert, peer, chan) ::
    //console.log @ 'connected to:', advert, peer


export function mqtt_disco(mqtt, url) ::
  url = new URL('.', url)

  let db_advert=new Map(), db_chans=new Map()
  let self = _mqtt_disco_.from @ mqtt, url, discover
  mqtt.on_topic @ url.pathname+':id', on_advert
  mqtt.subscribe(url.pathname + '#')
  return self

  function on_advert(pkt, params) ::
    let advert = pkt.json()
    if ! advert ::
      db_advert.delete(params.id)
      db_chans.delete(params.id)
    else db_advert.set(params.id, advert)

  async function to_advert(key, query) ::
    let advert, hub=query.router_ctx.hub
    for let i=self.retries; i>0; i-- ::
      advert = db_advert.get(key)
      if advert :: break
      await hub.timeouts.add(self.ms_backoff)

    return advert && self.channel_to(hub, advert, query)

  async function discover(query) ::
    let key = self.xform
      ? await self.xform(query)
      : query.id_route

    let cur = db_chans.get(key)
    if ! cur ::
      cur = to_advert(key, query)
      db_chans.set(key, cur)
    return cur

