import {MQTT_base} from './base.jsy'

export class MQTT_disco extends MQTT_base ::
  static from(pi_ctx, mqtt, url) ::
    return new this(pi_ctx)
      .with_mqtt(mqtt)
      .subscribe(url)

  subscribe(url) ::
    this.mqtt.on_topic @ url.pathname+':id',
      this._on_advert_pkt.bind(this)
    this.mqtt.subscribe(url.pathname + '#')
    return this.with @:
      url: new URL('.', url)
      db_adverts: new Map()
      db_chans: new Map()

  advert_from_pkt(pkt) ::
    return pkt.json()

  _on_advert_pkt(pkt, {id}) ::
    if 0 === pkt.payload.length ::
      this.db_adverts.delete(id)
      this.db_chans.delete(id)
      this.on_advert(id)
    else ::
      let advert = this.advert_from_pkt(pkt)
      this.db_adverts.set @ id, advert
      this.on_advert(id, advert)

  on_advert(pub_id, advert) ::
    //console.log @ 'advert:', pub_id, advert

  on_discovering(pub_id, query) ::
    //console.log @ 'discovering:', pub_id

  query_pub_id(query) :: return query.id_route

  // addDiscovery protocol {test, discover}
  test(query) :: return true
  async discover(query) ::
    let pub_id = await this.query_pub_id(query)
    let db_chans = this.db_chans
    let cur = db_chans.get(pub_id)
    if ! cur ::
      this.on_discovering(pub_id, query)
      cur = this._use_advert(pub_id, query)
      db_chans.set(pub_id, cur)
    return cur

  // ms_duration = 500
  async _use_advert(pub_id, query) ::
    let hub = query.router_ctx.hub,
        db_adverts = this.db_adverts,
        advert = db_adverts.get(pub_id)

    let ts_until = Date.now() + (this.ms_duration || 500)
    while !advert && !query.done && ts_until > Date.now() ::
      await hub.timeouts.f_tick()
      advert = await db_adverts.get(pub_id)

    return advert &&
      await this._channel_to(hub, pub_id, advert, query)

  async _channel_to(hub, pub_id, advert, query) ::
    if ! advert.conn ::
      return
    this.on_connecting(pub_id, advert)
    let chan = await hub.connect(advert.conn)
    let peer = await chan.peer_info

    this.db_chans.set(pub_id, chan)
    this.on_connect(pub_id, advert, peer, chan)
    return chan

  on_connecting(pub_id, advert) ::
    //console.log @ 'connecting:', pub_id, advert
  on_connect(pub_id, advert, peer, chan) ::
    //console.log @ 'connected to:', pub_id, advert

